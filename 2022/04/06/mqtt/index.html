<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="e10lZLZCvqy3sd9xN2geXQVn0vLio96zR92M4L7Vn0o" />

    
    <title>mqtt | Ant-Thinker</title>

    <meta name="description" content="&lt;h2 id=&#34;什么是MQTT&#34;&gt;&lt;a href=&#34;#什么是MQTT&#34; class=&#34;headerlink&#34; title=&#34;什么是MQTT&#34;&gt;&lt;/a&gt;&lt;strong&gt;什么是MQTT&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;MQTT 协议的全称是 &lt;strong&gt;Message Queuing Telemetry Transport&lt;/strong&gt;，翻译为消息队列传输探测，它是 ISO 标准下的一种基于&lt;strong&gt;发布 - 订阅&lt;/strong&gt;模式的消息协议，它是基于 TCP&amp;#x2F;IP 协议簇的，它是为了改善网络设备硬件的性能和网络的性能来设计的。MQTT 一般多用于 IoT 即物联网上，广泛应用于工业级别的应用场景，比如汽车、制造、石油、天然气等。&lt;/p&gt;">
    <meta name="keywords" content="Ant-Thinker JakeMa 马一栋 博客  个人博客">

    

    <meta property="og:locale" content="cn,ja,default" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "mqtt | Ant-Thinker"  />
    <meta property="og:description" content= "&lt;h2 id=&#34;什么是MQTT&#34;&gt;&lt;a href=&#34;#什么是MQTT&#34; class=&#34;headerlink&#34; title=&#34;什么是MQTT&#34;&gt;&lt;/a&gt;&lt;strong&gt;什么是MQTT&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;MQTT 协议的全称是 &lt;strong&gt;Message Queuing Telemetry Transport&lt;/strong&gt;，翻译为消息队列传输探测，它是 ISO 标准下的一种基于&lt;strong&gt;发布 - 订阅&lt;/strong&gt;模式的消息协议，它是基于 TCP&amp;#x2F;IP 协议簇的，它是为了改善网络设备硬件的性能和网络的性能来设计的。MQTT 一般多用于 IoT 即物联网上，广泛应用于工业级别的应用场景，比如汽车、制造、石油、天然气等。&lt;/p&gt;" />
    <meta property="og:url" content="https://jakemama.github.io/2022/04/06/mqtt/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="JakeMa" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="&lt;h2 id=&#34;什么是MQTT&#34;&gt;&lt;a href=&#34;#什么是MQTT&#34; class=&#34;headerlink&#34; title=&#34;什么是MQTT&#34;&gt;&lt;/a&gt;&lt;strong&gt;什么是MQTT&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;MQTT 协议的全称是 &lt;strong&gt;Message Queuing Telemetry Transport&lt;/strong&gt;，翻译为消息队列传输探测，它是 ISO 标准下的一种基于&lt;strong&gt;发布 - 订阅&lt;/strong&gt;模式的消息协议，它是基于 TCP&amp;#x2F;IP 协议簇的，它是为了改善网络设备硬件的性能和网络的性能来设计的。MQTT 一般多用于 IoT 即物联网上，广泛应用于工业级别的应用场景，比如汽车、制造、石油、天然气等。&lt;/p&gt;" />
    <meta name="twitter:title" content="mqtt | Ant-Thinker"/>
    <meta name="twitter:description" content="&lt;h2 id=&#34;什么是MQTT&#34;&gt;&lt;a href=&#34;#什么是MQTT&#34; class=&#34;headerlink&#34; title=&#34;什么是MQTT&#34;&gt;&lt;/a&gt;&lt;strong&gt;什么是MQTT&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;MQTT 协议的全称是 &lt;strong&gt;Message Queuing Telemetry Transport&lt;/strong&gt;，翻译为消息队列传输探测，它是 ISO 标准下的一种基于&lt;strong&gt;发布 - 订阅&lt;/strong&gt;模式的消息协议，它是基于 TCP&amp;#x2F;IP 协议簇的，它是为了改善网络设备硬件的性能和网络的性能来设计的。MQTT 一般多用于 IoT 即物联网上，广泛应用于工业级别的应用场景，比如汽车、制造、石油、天然气等。&lt;/p&gt;"/>
    <script type="application/ld+json">
        {
            "description": "&lt;h2 id=&#34;什么是MQTT&#34;&gt;&lt;a href=&#34;#什么是MQTT&#34; class=&#34;headerlink&#34; title=&#34;什么是MQTT&#34;&gt;&lt;/a&gt;&lt;strong&gt;什么是MQTT&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;MQTT 协议的全称是 &lt;strong&gt;Message Queuing Telemetry Transport&lt;/strong&gt;，翻译为消息队列传输探测，它是 ISO 标准下的一种基于&lt;strong&gt;发布 - 订阅&lt;/strong&gt;模式的消息协议，它是基于 TCP&amp;#x2F;IP 协议簇的，它是为了改善网络设备硬件的性能和网络的性能来设计的。MQTT 一般多用于 IoT 即物联网上，广泛应用于工业级别的应用场景，比如汽车、制造、石油、天然气等。&lt;/p&gt;",
            "author": { "@type": "Person", "name": "JakeMa" },
            "@type": "BlogPosting",
            "url": "https://jakemama.github.io/2022/04/06/mqtt/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "https://jakemama.github.ioundefined"
            },
            "name": "JakeMa"
            },
            "headline": "mqtt | Ant-Thinker",
            "datePublished": "2022-04-06T06:09:57.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https://jakemama.github.io/2022/04/06/mqtt/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    
    <meta property="algolia:search" data-application-id="96795YLOVI" data-api-key="" data-index-name="hexo">
    

    

    

    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>📖</text></svg>">
    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1646451311888.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1646451311888.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = true
        window.aomori_search_algolia = true

    </script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <div id="typed-strings" style="display:none">
                        <p>Ant-Thinker</p>
                    </div>
                    <a class="header-type-title" id="typed" href="/"></a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">存档</a>
                
                <a href="/photography">照片墙</a>
                
                <a href="/plan">年度计划</a>
                
            </div>
            <div class="header-menu-social">
                
    <a class="social" target="_blank" href="https://github.com/jakemama">
        <box-icon type='logo' name='github'></box-icon>
    </a>

            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">存档</a>
                    
                    <a href="/photography">照片墙</a>
                    
                    <a href="/plan">年度计划</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-clcgcz9cl000nq3uqg89gdoh4" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      mqtt
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2022-04-06T06:09:57.000Z" itemprop="datePublished">2022-04-06</time>
</div>

            
            <div class="article-category">
                <a class="article-category-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
            </div>
            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <h2 id="什么是MQTT"><a href="#什么是MQTT" class="headerlink" title="什么是MQTT"></a><strong>什么是MQTT</strong></h2><p>MQTT 协议的全称是 <strong>Message Queuing Telemetry Transport</strong>，翻译为消息队列传输探测，它是 ISO 标准下的一种基于<strong>发布 - 订阅</strong>模式的消息协议，它是基于 TCP&#x2F;IP 协议簇的，它是为了改善网络设备硬件的性能和网络的性能来设计的。MQTT 一般多用于 IoT 即物联网上，广泛应用于工业级别的应用场景，比如汽车、制造、石油、天然气等。</p>
<span id="more"></span>
<h2 id="MQTT基础"><a href="#MQTT基础" class="headerlink" title="MQTT基础"></a><strong>MQTT基础</strong></h2><p>MQTT 协议总结一点就是一种<strong>轻量级的二进制协议</strong>，MQTT 协议与 HTTP 相比具有一个明显的优势：<strong>数据包开销较小</strong>，数据包开销小就意味着更容易进行网络传输。</p>
<p>还有一个优势就是 MQTT 在客户端容易实现，而且具有易用性，非常适合当今资源有限的设备。</p>
<ul>
<li>协议必须易于实现；</li>
<li>协议中的数据必须易于传输，消耗成本小；</li>
<li>协议必须提供服务质量管理；</li>
<li>协议必须支持连续的会话控制</li>
<li>假设数据不可知，不强求传输数据的类型与格式，保持灵活性。</li>
</ul>
<h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a><strong>发布-订阅模式</strong></h3><p>发布 - 订阅模式我相信接触消息中间件架构的同学都听过，这是一种传统的<strong>客户端 - 服务器</strong>架构的替代方案，因为一般传统的客户端-服务器是客户端能够直接和服务器进行通信。</p>
<p>但是发布 - 订阅模式 <code>pub/sub</code>就不一样了，发布订阅模式会将发送消息的发布者 <code>publisher</code>与接收消息的订阅者 <code>subscribers</code>进行分离，<code>publisher</code> 与 <code>subscribers</code> 并不会直接通信，他们甚至都不清楚对方是否存在，他们之间的交流由第三方组件<code>broker</code>代理。</p>
<p><img src="/../images/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.png" alt="发布订阅模式"></p>
<p>pub&#x2F;sub 最重要的方面是 publisher 与 subscriber 的解藕，这种耦合度有下面三个维度：</p>
<ul>
<li><p><strong>空间解耦</strong>：publisher 与 subscriber 并不知道对方的存在，例如不会有 IP 地址和端口的交互，也更不会有消息的交互。</p>
</li>
<li><p><strong>时间解藕</strong>：publisher 与 subscriber 并不一定需要同时运行。</p>
</li>
<li><p><strong>同步 <code>Synchronization</code> 解藕</strong>：两个组件的操作比如 publish 和 subscribe 都不会在发布或者接收过程中产生中断。</p>
</li>
</ul>
<p>总之，发布&#x2F;订阅模式消除了传统客户-服务器之间的直接通信，把通信这个操作交给了 broker 进行代理，并在空间、时间、同步三个维度上进行了解藕。</p>
<h3 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a><strong>消息过滤</strong></h3><p>在 pub&#x2F;sub 的架构模式中，broker 扮演着至关重要的作用，其中非常重要的一点就是 broker 能够对消息进行过滤，使每个订阅者只接收自己感兴趣的消息。</p>
<ul>
<li><p><strong>基于主题的过滤</strong><br>MQTT 是基于 subject 的消息过滤的，每条消息都会有一个 topic ，接收客户端会向 borker 订阅感兴趣的 topic，订阅后，broker 就会确保客户端收到发布到 topic 中的消息。</p>
</li>
<li><p><strong>基于内容的过滤</strong><br>在基于内容的过滤中，broker 会根据特定的内容过滤消息，接受客户端会经过过滤他们感兴趣的内容。这种方法的一个显著的缺点就是必须事先知道消息的内容，不能加密或者轻易修改。</p>
</li>
<li><p><strong>基于类型的过滤</strong><br>在使用面向对象的语言时，基于消息（事件）的类型过滤是一种比较常见的过滤方式。</p>
</li>
</ul>
<h2 id="MQTT与消息队列的区别"><a href="#MQTT与消息队列的区别" class="headerlink" title="MQTT与消息队列的区别"></a><strong>MQTT与消息队列的区别</strong></h2><p>MQTT 是一种消息队列传输探测协议，这种协议是看似是以消息队列为基础，但却与消息队列有所差别。</p>
<p>在传统的消息队列模式中，一条消息会存储在消息队列中等待被消费，每个传入的消息都存储在消息队列中，直到它被客户端（通常称之为消费者）所接收，如果没有客户端消费消息的话，这条消息就会存在消息队列中等待被消费。但是在消息队列中，不会存在消息没有客户端消费的情况，但是在 MQTT 中，确存在 topic 无 subscriber 订阅的情况。</p>
<p>在传统的消息队列模式中，一条消息只能被一个客户端所消费，负载会分布在队列的每个消费者之间；而在 MQTT 中，每个订阅者都会受到消息，每个订阅者有相同的负载。</p>
<p>在传统的消息队列模式中，必须使用单独的命令来显式创建队列，只有队列创建后，才可以生产或者消费消息；而在 MQTT 中，topic 比较灵活，可以即时创建。</p>
<h2 id="MQTT重要概念"><a href="#MQTT重要概念" class="headerlink" title="MQTT重要概念"></a><strong>MQTT重要概念</strong></h2><h3 id="MQTT-client"><a href="#MQTT-client" class="headerlink" title="MQTT client"></a><strong>MQTT client</strong></h3><p>当我们讨论关于客户端的概念时，一般指的就是 MQTT Client，publisher 和 subscriber 都属于 MQTT Client。之所以有发布者和订阅者这个概念，其实是一种相对的概念，就是指当前客户端是在发布消息还是在接收消息，发布和订阅的功能也可以由同一个 MQTT Client 实现。</p>
<p>MQTT 客户端是指运行 MQTT 库并通过网络连接到 MQTT broker 的任何设备，这些设备可以从微控制器到成熟的服务器。基本上，任何使用 TCP&#x2F;IP 协议使用 MQTT 设备的都可以称之为 MQTT Client。MQTT 协议的客户端实现非常简单直接。易于实施是 MQTT 非常适合小型设备的原因之一。MQTT 客户端库可用于多种编程语言。例如，Android、Arduino、C、C++、C#、Go、iOS、Java、JavaScript 和 .NET。</p>
<h3 id="MQTT-broker"><a href="#MQTT-broker" class="headerlink" title="MQTT broker"></a><strong>MQTT broker</strong></h3><p>与 MQTT client 对应的就是 MQTT broker，broker 是任何发布&#x2F;订阅机构的核心，根据实现的不同，代理可以处理多达数百万连接的 MQTT client。</p>
<p>broker 负责接收所有消息，过滤消息，确定是哪个 client 订阅了每条消息，并将消息发送给对应的 client，broker 还负责保存会话数据，这些数据包括订阅的和错过的消息。broker 还负责客户端的身份验证和授权。</p>
<h3 id="MQTT-Connection"><a href="#MQTT-Connection" class="headerlink" title="MQTT Connection"></a><strong>MQTT Connection</strong></h3><p>MQTT 是基于 TCP&#x2F;IP 协议基础之上的，所以 MQTT 的 client 和 broker 都需要 TCP&#x2F;IP 协议的支持。</p>
<p>MQTT 的连接总是在 client 和 broker 之间进行，client 和 client 之间并不会相互连接。如果要发起连接的话，那么 client 就会向 broker 发起 <code>CONNECT</code> 消息，代理会使用 <code>CONNACK</code> 消息和状态码进行响应。一旦 client 和 broker 的连接建立后，broker 就会使客户端的连接一直处于打开状态，直到 client 发出断开命令或者连接中断。</p>
<h2 id="消息报文"><a href="#消息报文" class="headerlink" title="消息报文"></a><strong>消息报文</strong></h2><p>MQTT 的消息报文主要分为 CONNECT 和 CONNACK 消息。</p>
<h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a><strong>CONNECT</strong></h3><p>我们上面提到了为了初始化连接，需要 client 向 broker 发送 CONNECT 消息，如果这个 CONNECT 消息格式错误或者打开套接字（因为基于 TCP&#x2F;IP 协议栈需要初始化 Socket 连接）时间过长，亦或是发送连接消息时间过长的话，broker 就会关闭这条连接。</p>
<p>一个 MQTT 客户端发送一条 CONNECT 连接，这条 CONNECT 连接可能会包含下面这些信息：<br><img src="/../images/mqtt-CONNECT%E6%8A%A5%E6%96%87.png" alt="CONNECT报文"></p>
<ul>
<li><p><code>ClientId</code>：显而易见，这个就是每个客户端的 ID 标识，也就是连接到 MQTT broker 的每个 client。这个 ID 应该是每个 client 和 broker 唯一的，如果你不需要 broker 持有状态的话，你可以发送一个空的 ClientId，空的 ClientId 会没有任何状态。在这种情况下，<code>ClientSession</code> 需要设置为 true，否则将会拒绝连接。</p>
</li>
<li><p><code>clientSession</code> 是什么我们下面会说。</p>
</li>
<li><p><code>CleanSession</code>：CleanSession 会话标志会告诉 broker client 是否需要建立持久会话。在持久会话 （CleanSession &#x3D; false）中，broker 存储 client 的所有订阅以及<strong>服务质量(Qos)</strong> 是 1 或 2 订阅的 client 的所有丢失的消息。如果会话不是持久的（CleanSession &#x3D; true），那么 broker 则不会为 client 存储任何内容并且会清除先前持久会话中的所有信息。</p>
</li>
<li><p><code>Username/Password</code> ：MQTT 会发送 username 和 password 进行 client 认证和授权。如果此信息没有经过加密或者 hash ，那么密码将会以纯文本的形式发送。所以，一般强烈建议 username 和 password 要经过加密安全传输。像 HiveMQ 这样的 broker 可以与 SSL 证书进行身份验证，因此不需要用户名和密码。</p>
</li>
<li><p><code>LastWillxxx</code> ：LastWillxxx 表示的是遗愿，client 在连接 broker 的时候将会设立一个遗愿，这个遗愿会保存在 broker 中，当 client 因为<strong>非正常原因</strong>断开与 broker 的连接时，broker 会将遗愿发送给订阅了这个 topic（订阅遗愿的 topic）的 client。</p>
</li>
<li><p><code>keepAlive</code>：keepAlive 是 client 在连接建立时与 broker 通信的时间间隔，通常以秒为单位。这个时间指的是 client 与 broker 在不发送消息下所能承受的最大时长。</p>
</li>
</ul>
<h3 id="CONNACK"><a href="#CONNACK" class="headerlink" title="CONNACK"></a><strong>CONNACK</strong></h3><p>当 broker 收到 CONNECT 消息时，它有义务回复 CONNACK 消息进行响应。CONNACK 消息包括两部分内容<br><img src="/../images/mqtt-CONNACK%E6%8A%A5%E6%96%87.png" alt="CONNACK报文"></p>
<ul>
<li><p><code>SessionPresent</code>：会话当前标识，这个标志会告诉 client 当前 broker 是否有一个持久性会话与 client 进行交互。SessionPresent 标志和 CleanSession 标志有关，当 client 在 CleanSession 设置为 true 的情况下连接时，SessionPresent 始终为 false，因为没有持久性会话可以使用。如果 CleanSession 设置为 false，则有两种可能性，如果 ClientId 的会话信息可用，并且 broker 已经存储了会话信息，那么 SessionPresent 为 true，否则如果没有 ClientId 的任何会话信息，那么 SessionPresent 为 false。<br><img src="/../images/mqtt%E6%8C%81%E4%B9%85%E6%80%A7%E4%BC%9A%E8%AF%9D.png" alt="持久性会话"></p>
</li>
<li><p><code>ReturnCode</code>：CONNACK 消息中的第二个标志是连接确认标志。这个标志包含一个返回码，告诉客户端连接尝试是否成功。连接确认标志有下面这些选项。</p>
<table>
<thead>
<tr>
<th align="left">返回码</th>
<th align="left">返回码含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">已接受连接</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">连接被拒绝，不可接受的协议版本</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">连接被拒绝，标识符被拒绝</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">连接被拒绝，服务器不可用</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">连接被拒绝，用户名或密码错误</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">连接被拒绝，未授权</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a><strong>消息类型</strong></h2><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a><strong>发布</strong></h3><p>当 MQTT client 在连接到 broker 之后就可以发送消息了，MQTT 使用的是基于 topic 主题的过滤。每条消息都应该包含一个 topic ，broker 可以使用 topic 将消息发送给感兴趣的 client。除此之外，每条消息还会包含一个**负载(Payload)**，Payload 中包含要以字节形式发送的数据。</p>
<p>MQTT 是数据无关性的，也就是说数据是由发布者 - publisher 决定要发送的是 XML 、JSON 还是二进制数据、文本数据。</p>
<p>MQTT 中的 PUBLISH 消息结构如下。<br><img src="/../images/mqtt-PUBLISH%E7%BB%93%E6%9E%84.png" alt="PUBLISH"></p>
<ul>
<li><p><code>Packet Identifier</code>：这个 PacketId 标识在 client 和 broker 之间唯一的消息标识。packetId 仅与大于零的 Qos 级别相关。</p>
</li>
<li><p><code>TopicName</code>：主题名称是一个简单的字符串，<code>/</code> 代表着分层结构。</p>
</li>
<li><p><code>Qos</code>：这个数字表示的是服务质量水平，服务质量水平有三个等级：0、1 和 2，服务级别决定了消息到达 client 或者 broker 的保证类型，来决定消息是否丢失。</p>
</li>
<li><p><code>RetainFlag</code>：这个标志表示 broker 将最近收到的一条 RETAIN 标志位为<code>true</code>的消息保存在服务器端（内存或者文件）。</p>
</li>
</ul>
<blockquote>
<p>MQTT 服务器只会为每一个 Topic 保存最近收到的一条 RETAIN 标志位为<code>true</code>的消息。也就是说，如果MQTT 服务器上已经为某个 Topic 保存了一条 Retained 消息，当客户端再次发布一条新的 Retained 消息时，那么服务器上原来的那条消息会被覆盖。</p>
</blockquote>
<ul>
<li><p><code>Payload</code>：这个是每条消息的实际内容。MQTT 是数据无关性的。可以发送任何文本、图像、加密数据以及二进制数据。</p>
</li>
<li><p><code>Dupflag</code>：这个标志表示该消息是重复的并且由于预期的 client 或者 broker 没有确认所以重新发送了一次。这个标志仅仅与 Qos 大于 0 相关。</p>
</li>
</ul>
<p>当 client 向 broker 发送消息时，broker 会读取消息，根据 Qos 的级别进行消息确认，然后处理消息。处理消息其实就是确定哪些 subscriber 订阅了 topic 并将消息发送给他们。</p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a><strong>订阅</strong></h3><p>client 会向 broker 发送 SUBSCRIBE 消息来接收有关感兴趣的 topic，这个 SUBSCRIBE 消息非常简单，它包含了一个唯一的数据包标识和一个订阅列表。<br><img src="/../images/mqtt%E8%AE%A2%E9%98%85.png" alt="订阅"></p>
<ul>
<li><p><code>Packet Identifier</code>：这个 PacketId 和上面的 PacketId 一样，都表示消息的唯一标识符。</p>
</li>
<li><p><code>ListOfSubscriptions</code>：SUBSCRIBE 消息可以包含一个 client 的多个订阅，每个订阅都会由一个 topic 和一个 Qos 构成。订阅消息中的 topic 可以包含通配符。</p>
</li>
</ul>
<h3 id="确认消息"><a href="#确认消息" class="headerlink" title="确认消息"></a><strong>确认消息</strong></h3><p>client 在向 broker 发送 SUBSCRIBE 消息后，为了确认每个订阅，broker 会向 client 发送 SUBACK 确认消息。这个 SUBACK 包含原始 SUBSCRIBE 消息的 packetId 和返回码列表。<br><img src="/../images/mqtt%E7%A1%AE%E8%AE%A4%E6%B6%88%E6%81%AF.png" alt="确认消息"></p>
<ul>
<li><p><code>Packet Identifier</code> ：这个数据包标识符和 SUBSCRIBE 中的相同。</p>
</li>
<li><p><code>ReturnCode：broker</code> 为每个接收到的 SUBSCRIBE 消息的 topic&#x2F;Qos 对发送一个返回码。例如，如果 SUBSCRIBE 消息有五个订阅消息，则 SUBACK 消息包含五个返回码作为响应。</p>
</li>
</ul>
<h3 id="退订和确认退订"><a href="#退订和确认退订" class="headerlink" title="退订和确认退订"></a><strong>退订和确认退订</strong></h3><p>SUBSCRIBE 消息对应的是 <code>UNSUBSCRIBE</code> 消息，这条消息发送后，broker 会删除关于 client 的订阅。所以，UNSUBSCRIBE 消息与 SUBSCRIBE 消息类似，都具有 packetId 和 topic 列表。</p>
<p>取消订阅也需要 broker 的确认，此时 broker 会向 client 发送一个 <code>UNSUBACK</code> 消息，这个 UNSUBACK 消息非常简单，只有一个 packetId 数据标识符。<br><img src="/../images/mqtt%E9%80%80%E8%AE%A2.png" alt="确认消息"></p>
<h2 id="聊聊-Topic"><a href="#聊聊-Topic" class="headerlink" title="聊聊 Topic"></a><strong>聊聊 Topic</strong></h2><p>聊了这么多关于 MQTT 的内容，但是我们还没有好好聊过 Topic。在 MQTT 中，Topic 是指 broker 为每个连接的 client 过滤消息的 <code>UTF-8</code> 字符串。Topic 是一种分层的结构，可以由一个或者多个 Topic 组成。每个 Topic 由 <code>/</code>进行分割。</p>
<p>与传统的消息队列相比，MQTT Topic 非常轻量级，client 在发布或订阅之前不需要先创建所需要的 Topic，broker 在接收每个 Topic 前不用进行初始化操作。</p>
<p>当客户端订阅 Topic 时，它可以订阅已发布消息的确切 Topic，也可以使用<strong>通配符</strong>来同时订阅多个 Topic。通配符有两种：<strong>单级和多级</strong>。</p>
<h3 id="单级通配符"><a href="#单级通配符" class="headerlink" title="单级通配符"></a><strong>单级通配符</strong></h3><p>单级通配符可以替换 Topic 的一个级别，<code>+</code> 号代表 Topic 中的单级通配符。</p>
<h3 id="多级通配符"><a href="#多级通配符" class="headerlink" title="多级通配符"></a><strong>多级通配符</strong></h3><p>多级通配符涵盖多个 Topic，<code>#</code> 代表 Topic 中的多级通配符。为了让 broker 能够确定和哪些 Topic 匹配，多级通配符必须作为 Topic 中的最后一个字符放置，并以 <code>/</code> 开头。</p>
<p>当 client 订阅带有多级通配符的 Topic 时，不论 Topic 有多长多深，它都会收到通配符之前 Topic 的所有消息。如果你只将 Topic 定义为 # 的话，那么你将会收到所有的消息。</p>

        </div>

    </div>

    

    

    

    
  <div class="article-copyright hairline">
    <p>
      本作品采用  <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/">知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 (CC BY-NC-ND 4.0)</a> 进行许可。
    </p>
  </div>
  

    

    
<nav class="article-nav">
  
    <a href="/2022/04/22/%E5%A6%82%E4%BD%95%E8%B6%85%E8%BF%87%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          如何超过大多数人
        
      </div>
    </a>
  
  
    <a href="/2022/04/06/%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">虚拟dom和diff算法</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=mqtt - Ant-Thinker&url=https://jakemama.github.io/2022/04/06/mqtt/">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=mqtt - Ant-Thinker&u=https://jakemama.github.io/2022/04/06/mqtt/">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=mqtt - Ant-Thinker&url=https://jakemama.github.io/2022/04/06/mqtt/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>
















</div>
                </section>
            </section>

            
            <aside class="sidebar sidebar-search-fix">
                

    <div class="search">
    <div class="has-icon-right">
        <input type="text" class="form-input" id="search" placeholder="SEARCH" autocomplete="off">
        <div class="form-icon">
            <box-icon name='search' color="#3c4859"></box-icon>
        </div>
    </div>
    <div class="search-result" id="search-ps"></div>
</div>


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-cate">
    <div class="widget-title"><span>Categories</span></div>
    <div class="widget-inner">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8/">安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%89%A9%E8%81%94%E7%BD%91/">物联网</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9A%8F%E7%AC%94/">随笔</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bug/" rel="tag">bug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/" rel="tag">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mqtt/" rel="tag">mqtt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/" rel="tag">node</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pixi-js/" rel="tag">pixi.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/puppeteer/" rel="tag">puppeteer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/" rel="tag">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag">可视化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%88%E7%8E%87/" rel="tag">效率</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2023/01/03/git%E7%9A%84ssh%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98/">git报错kex_exchange_identification: Connection closed by remote host</a>
          </li>
        
          <li>
            <a href="/2023/01/03/%E5%BD%93%E8%B4%9DDBH2%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%E7%BF%BB%E5%A2%99%E8%A7%82%E7%9C%8BYouTube/">当贝DBH2电视盒子翻墙观看YouTube</a>
          </li>
        
          <li>
            <a href="/2022/12/29/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/">2022年终总结</a>
          </li>
        
          <li>
            <a href="/2022/11/23/axios%E5%B0%81%E8%A3%85%E6%96%B9%E6%A1%88/">axios封装方案</a>
          </li>
        
          <li>
            <a href="/2022/11/01/%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%BA%93%E3%80%81%E6%96%B9%E6%A1%88/">前端常用库、方案</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Ant-Thinker &copy; 2023<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1646451311888.js"></script>


<script src="/dist/custom.js?1646451311888.js"></script>





<!-- Google Analytics-->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NG4NENLKCQ"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-NG4NENLKCQ');
</script>









</body>

</html>